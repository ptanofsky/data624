---
title: "Technical Report: Determinants of PH in Beverage Process"
subtitle: ""
author: "Alexander Ng, Philip Tanofsky"
date: "Due 12/13/2021"
output:
  tufte::tufte_html: 
    toc: true
    toc_depth: '2'
    highlight: pygments
    number_sections: no
  pdf_document:
    toc: yes
    toc_depth: '2'
  html_document:
    df_print: paged
    highlight: tango
    number_sections: yes
    theme: readable
    toc: yes
    toc_depth: 0
    toc_float: no
    fontsize: 12
editor_options:
  chunk_output_type: inline
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r config-vars}
# Conditional Code Evaluation is managed here.

```

```{r warning=FALSE, message=FALSE}
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(kableExtra))
suppressPackageStartupMessages(library(rpart.plot))
suppressPackageStartupMessages(library(partykit))
suppressPackageStartupMessages(library(gbm))
library(cowplot)
library(skimr)
library(GGally) # for ggpairs
library(readxl) # to parse Excel workbooks
library(openxlsx) # for writing xlsx files
library(corrplot)
library(RColorBrewer)
library(caret)
library(VSURF)
library(Cubist)
library(rpart)
library(party)
library(writexl)
```

```{css, echo=FALSE}
.code-bg {
  background-color: lightgray;
}
```

# Introduction

This technical report tunes multiple models for prediction of beverage PH and identifies determinants of PH among predictors in the manufacturing process.
We train and test 5 models for this purpose including the Cubist, Gradient Boosted Tree, CART, MARS and linear regression models.

The training and test performance are evaluated separately on the StudentData dataset with the metrics RMSE and $R^2$ to determine the model algorithm most appropriate for predicting the PH of the StudentEvaluation dataset.

# Data Wrangling Strategy

We will describe the data wrangling steps in brief before doing any exploratory data analysis and model building.
After loading the raw data files, our transformations and changes are as follows:

1.   Add a primary key `id` to allow unique identification of all raw observations.
2.   Drop observations with NA in the response variable `PH`.
3.   Drop observations with a high number of missing values.  In our case, observations that have more than 4 missing values.
4.   Rename the variables to remove spaces.
5.   Split the initial data set using stratified sampling based on `PH` value into a 80/20 train and validate data set.  We recognize that a test data set exists but this is for external assessment of the project prediction accuracy.
6.   Identify and drop near zero variance predictors in the training set.  And apply the same predictor removals to the validation data set (regardless of their values in the latter).
7.   Identify and fix zeros and outliers in the predictors in the training set as follows:
  + Identify outliers based on extreme Z scores (e.g. the z-score of the predictor min and max)
  + Decide if their values are plausible or implausible.  Choose an outlier threshold.
  + Replace all such values by the column median among the training set population.

8.   Handle special cases of variables:
  +  Replace the missing `BrandCode` categorical value with a dummy BrandCode `E`
  +  Impute `MFR` missing value with the training set median.
  
9.   Apply the knn imputation strategy to Box-Cox transformed, scaled, centered observations for all training set points.

Along the way, we will assess the numerical impact of such changes to the dataset.


```{r}

raw_StudentData <- read_excel("StudentData.xlsx")
dim(raw_StudentData)
```

Let's evaluate the data characteristics of the raw file after loading.  We use the `skimr` library to get statistics quickly for the entire training data set.   The table below shows the numeric variables sorted by their completion rate in descending order.  So the most problematic
predictors are at the top of the table.

```{r}
skim(raw_StudentData) %>% 
  yank("numeric") %>% 
  arrange( complete_rate) %>% 
  kable( digits = 3 ) %>% 
  kable_styling(bootstrap_options = c("hover", "striped"), position = "left")

```


Next, we display the one character variable `Brand` below and its `skimr` output below.

```{r}
skim(raw_StudentData) %>% yank("character") %>%
  kable(  caption = "Character Variables in Beverage Data" , digits = 3) %>% 
  kable_styling(bootstrap_options = c("hover", "striped"), position = "left")

```

After loading the raw Excel file, we find the training dataset has 2571 observations with 32 predictors and 1 response variable `PH`.


General observations about the `skimr` results:

*   The predictor `MFR` is missing the most data:  about 8% (212) of its observations are missing.  The percentage of missing observations is too high for automated imputation in our opinion.  
*   The predictor `Filler Speed` is missing the next most data: about 2.2% (57) of its observations are missing.  The percentage is low enough for us to consider imputation.
*   The overall data completeness rate is very high.  We regard this dataset has being very high quality.  21 predictors have completeness rates over 99%.  Except for `MFR`, `Brand`, all of the other predictors have data completeness rates over 97.8%.   Therefore, except for `Brand` and `MFR`, an automated data imputation policy can be considered for those columns.
*   The response `PH` has 4 missing observations.   We will decide to drop those 4 observations as we do not wish to impute the response.


Our first transformation below is to add a unique identifier `id` based on row number to obtain a primary key.  
Then we drop the 4 observations which are missing `PH` values, rearrange the response variable `PH` and `BrandCode` for our convenience.
Lastly, we also eliminate spaces from the predictor column names to avoid using quote in our code.


```{r echo = TRUE }
raw_StudentData %>% 
  rename_with(~ str_replace(., " ", ""),  everything() ) %>%
  mutate( id = row_number() )  %>% 
  relocate(id) %>%
  relocate(PH, .after = id) %>%
  relocate(`BrandCode`, .after = `BallingLvl` ) %>%
  filter( !is.na(PH)) %>% as_tibble() ->  sdata_v1

dim(sdata_v1)
```

## Rows with Missing Data

Is there any observations with a high number of missing observations?  


```{r echo= TRUE}
# include any rows where any column is NA.  Always include id column
sdata_v1 %>% dplyr::filter_all( any_vars(is.na(.))) -> x1  

# only include those columns where some row has NA in that column
# this dataset has no id column / so no primary key
x1 %>% select_if( ~ any(is.na(.) ) ) -> x2

# But the order of the missing observations is same in x1 and x2
# so add back the id and put it on the left side of tibble
x2 %>% mutate( id = x1$id  ) %>% relocate(id)-> missing_train_rows
  
dim(missing_train_rows)
```

We find there are 529 observations with NA observations.  So `r sprintf("%.1f%%", 100* nrow(x2)/nrow(sdata_v1))` have NA values.
We conclude that the NA values are sufficiently well distributed that removal of all observations with NA values is impractical.

In the marginal table below, we investigate if certain observations have a high incidence of NA values amongst their predictors.
The answer shows that the incident of multiple 

```{r}
missing_train_rows %>% mutate( num_na = rowSums(is.na(.))) -> missing_train_summary

missing_train_summary %>% group_by(num_na) %>%
  summarize( count = n()) %>%
  kable( caption = "Number of Rows with NA") %>%
  kable_styling(position = "left", bootstrap_options = c("hover", "striped"))
```

```{r}
num_na_cells = sum( missing_train_summary$num_na)
num_cells = nrow(sdata_v1) * 32  # excludes the response variable PH since we dropped its values.

print(paste0("There are ", num_na_cells , " cells with NA values out of ", num_cells, " equivalent to: " , sprintf("%.2f%%", 100 * num_na_cells / num_cells ) ) )
```

Overall, only 1 percent of cells have missing values.  
The concentration of missing values seems to decline at a geometric ratio suggesting
independence among the occurrence of missing values.

# Evaluation of Missing Data in the Test Set

```{r}
raw_StudentEvaluation <- read_excel("StudentEvaluation.xlsx")
dim(raw_StudentEvaluation)
```


```{r}
skim(raw_StudentEvaluation) %>% 
  yank("numeric") %>% 
  arrange( complete_rate) %>% 
  kable( digits = 3 ) %>% 
  kable_styling(bootstrap_options = c("hover", "striped"), position = "left")

```

```{r}
skim(raw_StudentEvaluation) %>% yank("character") %>%
  kable(  caption = "Character Variables in Beverage Data" , digits = 3) %>% 
  kable_styling(bootstrap_options = c("hover", "striped"), position = "left")
```


```{r}
raw_StudentEvaluation %>% 
  rename_with(~ str_replace(., " ", ""),  everything() ) %>%
  mutate( id = row_number() )  %>% 
  relocate(id) %>%
  relocate(PH, .after = id) %>%
  relocate(`BrandCode`, .after = `BallingLvl` )  %>% as_tibble() ->  edata_v1

dim(edata_v1)
```


```{r echo= TRUE}
# include any rows where any column is NA.  Always include id column
#
#  NOTE THAT WE EXCLUDE PH because the response variable (by design) is NA
#  for all observations in the test set.
edata_v1 %>% select(-PH) %>% dplyr::filter_all( any_vars(is.na(.))) -> ex1  

# only include those columns where some row has NA in that column
# this dataset has no id column / so no primary key
ex1 %>% select_if( ~ any(is.na(.) ) ) -> ex2

# But the order of the missing observations is same in x1 and x2
# so add back the id and put it on the left side of tibble
ex2 %>% mutate( id = ex1$id  ) %>% relocate(id)-> missing_test_rows
  
dim(missing_test_rows)
```


```{r}
missing_test_rows %>% mutate( num_na = rowSums(is.na(.))) -> missing_test_summary

missing_test_summary %>% group_by(num_na) %>%
  summarize( count = n()) %>%
  kable( caption = "Number of Rows with NA") %>%
  kable_styling(position = "left", bootstrap_options = c("hover", "striped"))
```

```{r}
num_na_cells_test = sum( missing_test_summary$num_na)
num_cells_test = nrow(edata_v1) * 32  # excludes the response variable PH since we dropped its values.

print(paste0("There are ", num_na_cells_test , " cells with NA values (excluding PH) out of ", num_cells_test, " equivalent to: " , 
             sprintf("%.2f%%", 100 * num_na_cells_test / num_cells_test ) ) )


```

```{r}
skim_sdata = skim(sdata_v1)
skim_edata = skim(edata_v1)

skim_sdata %>% select(  skim_variable, n_missing, complete_rate) %>% inner_join(skim_edata %>% select(skim_variable, n_missing, complete_rate), by = c("skim_variable") ) %>% filter(skim_variable != 'PH' ) -> skim_complete_rates 

skim_complete_rates %>% rename( training_complete = complete_rate.x, testing_complete = complete_rate.y) -> skim_complete_rates
```

```{r warning=FALSE, message=FALSE}
skim_complete_rates %>% as_tibble() %>%  ggplot(aes(x=training_complete, y = testing_complete)) + 
  geom_point() + geom_smooth(method = "lm") + theme(aspect.ratio = 1) + lims( x = c(0.95, 1), y = c(0.95, 1)) +
  labs(title = "Completion Rate by Predictor between Training and Test Sets")

```

We conclude that the distribution of missing values in the test set is:

*    the completeness rate of each predictors in the test and training sets are comparable (as illustrated by the scatter plot and linear regression line above)
*    shows 1.25% of cells are missing out - a very similar rate to the training set.
*    the distribution of missing values grouped by observation appears to be similar to the training set too.   The frequency of multiple missing values appears independent and declines geometrically with the number of missing values.

# Exploratory Data Analysis

## Scatterplot of Predictor Variables

The scatterplots of the predictor variables against the dependent variable `PH` indicate no clear linear relationship with any predictor variable. The scatterplots indicate some variable measurements are not continuous and instead fall on specific values on the x-axis.

```{r warning=F, message=F, fig.width=12, fig.height=10}
# Feature plot for the numeric predictor variables against the result variable PH
cols <- sdata_v1 %>%
  select(-c('id', 'BrandCode', 'PH')) %>% colnames()

featurePlot(sdata_v1[,cols], 
            sdata_v1$PH, 
            plot="scatter",
            type = c("p", "smooth"),
            span = .5,
            layout=c(6,6))
```

## Density Plots

The density plots of each predictor variable show many predictor variables with non-normal distributions.

```{r warning=F, message=F, fig.width=12, fig.height=10}
#https://statisticsglobe.com/histogram-density-for-each-column-data-frame-r
data_long <- sdata_v1[,cols] %>%
  pivot_longer(cols) %>%
  as.data.frame()

ggp2 <- ggplot(data_long, aes(x = value)) +
  geom_density() +
  facet_wrap(~ name, scales="free") +
  labs(title = "Density Plot of Predictor Variables")
ggp2
```

## Normality Test

The Shapiro-Wilk test of normality is performed on all the numeric predictor variables and the resulting list confirms no p-value above 0.05 and thus no predictor variable follows a normal distribution per evaluation.

```{r warning=F, message=F}
# http://www.sthda.com/english/wiki/normality-test-in-r
# From the output, the p-value > 0.05 implying that the distribution of the data are not significantly different from normal distribution. In other words, we can assume the normality.
shap_test_res <- lapply(sdata_v1[,cols], shapiro.test)
# Result: None of the numeric variables are normally distributed.

# https://stackoverflow.com/questions/62306712/how-to-select-only-the-p-value-0-05-after-performing-shapiro-wilk-test-in-rstud
subset_vector  <- sapply(shap_test_res, function(x) x$p.value > .05)
results_subset <- shap_test_res[subset_vector]

length(results_subset)
```

## Distribution by Brand Code

The distribution of the Brand Code, the lone non-numeric predictor variable, shows a high count of brand B, comprising almost half of the samples. Also note, some values are missing for the Brand Code variable.

```{r warning=F, message=F}
ggplot(data = sdata_v1) +
  geom_bar(mapping = aes(x = `BrandCode`)) +
  labs(title = "Distribution of Brand Code")
```

## Boxplot of PH by Brand Code

The boxplot of PH values by Brand Code certainly captures overlap of the middle two quartiles, which seems reasonable given the PH range is rather narrow. Of note, the median values of the 4 labeled brands and the unlabeled group do appear distinct besides Brand A and the unlabeled.

```{r warning=F, message=F}
ggplot(data = sdata_v1, mapping = aes(x = `BrandCode`, y = PH)) +
  geom_boxplot() +
  labs(title = "Boxplot of Brand Code")
```

## VSURF

To find significant variables for the models, the VSURF algorithm is applied to the provided dataset. The algorithm identifies 14 variables as significant to the predictions.

* Mnf Flow
* Usage cont
* Carb Rel
* Filler Level
* Alch Rel
* Bowl Setpoint
* Balling Lvl
* Carb Flow
* Temperature
* Oxygen Filler
* Balling
* Pressure Vacuum
* Filler Speed
* Hyd Pressure1

```{r warning=F, message=F}
sdata_v1_no_nas <- sdata_v1 %>% drop_na()

bev.vsurf <- VSURF(sdata_v1_no_nas[,cols], 
                   sdata_v1_no_nas$PH,
                   ntree = 10,
                   nfor.thres = 20,
                   nfor.interp = 10, nfor.pred = 10)
bev.vsurf
```

```{r warning=F, message=F}
summary(bev.vsurf)
```

```{r warning=F, message=F}
bev.vsurf$varselect.pred
```

## Data Partition into Training and Test Sets

Next we partition the student evaluation data set by training and test sets. We will retain the terminology of test set to refer to the validation data set used for model performance assessment outside of the cross validation process.

```{r echo = TRUE, class.source = 'code-bg'}
set.seed(19372)
train_indices = createDataPartition( sdata_v1$PH , times = 1, list = FALSE, p = 0.80 )

sdata_test    = sdata_v1[-train_indices , ]
sdata_train   = sdata_v1[ train_indices , ]
sdataY_test   = sdata_v1$PH[-train_indices ]
sdataY_train  = sdata_v1$PH[ train_indices ]

```

## Drop Near Zero Variance Predictors

We conclude there are no near zero variance predictors or constant predictors to be dropped from the training data set.

```{r}
nearZeroVar(sdata_train, saveMetrics = TRUE) %>% 
  kable(caption = "No Near Zero Variance Predictors in Training", digits = 2 ) %>%
  kable_styling(bootstrap_options = c("hover", "striped"), position = "left")

```

## Outliers and Zeros

Next we identify and fix zeros and outliers in the predictors before imputing missing values.  
The reason is that KNN algorithm may be affected by outliers.
The table below uses `skim` to report the minimum, maximum, median, mean and standard deviation for each predictor.
In addition, we construct Z-score metrics that tells us how many standard deviations is the minimum and maximum.


$$ \text{zscore_min}(X_i) = \frac{ min(X_i) - \mu(X_i) }{\sigma(X_i)}$$
$$\text{zscore_max}(X_i) = \frac{ max(X_i) - \mu(X_i) }{\sigma(X_i )}$$


```{r}
skim(sdata_train) %>% 
 mutate( zscore_min = ((numeric.p0 - numeric.mean) / (numeric.sd) ) ,
          zscore_max = ((numeric.p100 - numeric.mean) / (numeric.sd) ) ,
          zscore_extreme = ifelse( abs(zscore_min) > abs(zscore_max) , abs(zscore_min), zscore_max )
          )  %>%
  filter( zscore_extreme > 4 , skim_variable != 'PH') %>%
  arrange( desc(zscore_extreme)) %>%
  dplyr::select(skim_variable, n_missing, complete_rate, numeric.mean, numeric.sd, numeric.hist, zscore_min, zscore_max ) %>%
  kable(digits = 2, caption = "Predictors with Outliers by Z-Score" ) %>%
  kable_styling(bootstrap_options = c("hover" , "striped"), position = "left")
```

Using scatterplots of each of the 7 identified predictors below, we see no obvious data errors exist in the distribution of the predictors with outlier values.   
Isolated points exist but lie within a reasonable proximity to neighboring points in the scatter plot.
Therefore no data corrections for outliers will be applied to the training data.

```{r error=FALSE, warning=FALSE, message= FALSE}
pl1 = sdata_train %>% ggplot(aes(x=PH, y = MFR)) + geom_point(size=0.3) + theme(aspect.ratio = 1)
pl2 = sdata_train %>% ggplot(aes(x=PH, y = OxygenFiller)) + geom_point(size=0.3) + theme(aspect.ratio = 1)
pl3 = sdata_train %>% ggplot(aes(x=PH, y = Temperature)) + geom_point(size=0.3) + theme(aspect.ratio = 1)
pl4 = sdata_train %>% ggplot(aes(x=PH, y = CarbRel)) + geom_point(size=0.3) + theme(aspect.ratio = 1)
pl5 = sdata_train %>% ggplot(aes(x=PH, y = AirPressurer)) + geom_point(size=0.3) + theme(aspect.ratio = 1)
pl6 = sdata_train %>% ggplot(aes(x=PH, y = PSCCO2)) + geom_point(size=0.3) + theme(aspect.ratio = 1)
pl7 = sdata_train %>% ggplot(aes(x=PH, y = FillPressure)) + geom_point(size=0.3) + theme(aspect.ratio = 1)

plotlist= list(pl1, pl2, pl3, pl4, pl5, pl6, pl7)
plot_grid(plotlist=plotlist, nrow = 2 )

```

## Handle Special Cases

The code below will transform the special case situations of data pre-processing identified earlier:

*   Replace the MFR missing values with its median value from the training set
*   Replace the missing BrandCode with a fictional brand code `E`.

These rules are applied consistently to be the training, validation and test data sets prior to subsequent pre processing.

```{r}

median_MFR = median( sdata_train$MFR  , na.rm = TRUE ) 

sdata_train %>% 
  mutate( MFR = ifelse( is.na(MFR), median_MFR, MFR)) %>%
  mutate( BrandCode = ifelse( is.na(BrandCode), "E", BrandCode))  -> sdata_v2_train

sdata_test  %>% 
  mutate( MFR = ifelse( is.na(MFR), median_MFR, MFR)) %>%
  mutate( BrandCode = ifelse( is.na(BrandCode), "E", BrandCode))  -> sdata_v2_test

edata_v1 %>%
  mutate( MFR = ifelse( is.na(MFR), median_MFR, MFR)) %>%
  mutate( BrandCode = ifelse( is.na(BrandCode), "E", BrandCode)) ->  edata_v2


```

## KNN Imputation

We apply the caret pre processing function to that training, validation and test data sets.

```{r echo =TRUE}

# Build the caret function to preprocess the Chemical data and impute missing values.
# There is a bug in caret which causes tibbles to be rejected.  They need to be cast as data frames.
# ---------------------------------------------------------------------------------
preProcFunc = preProcess(as.data.frame(sdata_v2_train[,3:33]) , method = c("BoxCox", "center", "scale",  "knnImpute") )

# Becomes the source data for the model building
sdata_train_pp = predict( preProcFunc,  as.data.frame(sdata_v2_train ) )

# Becomes the final version of test data for validation
sdata_test_pp  = predict( preProcFunc,  as.data.frame(sdata_v2_test) )

# Need to generate predictions based on test data without known response
edata_test_pp  = predict( preProcFunc,  as.data.frame(edata_v2) )


sdata_trainX_pp  = sdata_train_pp %>% select( -PH)
sdata_testX_pp   = sdata_test_pp %>% select(-PH)
edata_testX_pp   = edata_test_pp %>% select( -PH)

```

```{r}
skim(sdata_train_pp)
```

```{r}
skim(sdata_test_pp)
```

```{r}
skim(edata_test_pp)
```

# Data visualization

First, we consider a correlation matrix where pairwise complete observations are allowed for use in computing correlations. Due to the low percentage of incomplete cells in the dataset, we prefer this dropping observations with any incomplete columns.

The correlation matrix below uses hierarchical clustering of the predictors to form 6 groups of variables using the `corrplot` package.  This was the most efficient way to gain insight on the related clusters of variables.

```{r message = FALSE, warning = FALSE, echo = TRUE}
M = cor(sdata_v1[,2:33], use = "pairwise.complete.obs")

corrplot::corrplot(M, method = "ellipse", order = "hclust", addrect = 6 ,  tl.cex = 0.7 )
```

We compare the correlations to the cleaned pre-processed training data.

```{r message = FALSE, warning = FALSE, echo = TRUE}
Mpp = cor(sdata_train_pp[,2:33], use = "pairwise.complete.obs")
corrplot::corrplot(M, method = "ellipse", order = "hclust", addrect = 6 ,  tl.cex = 0.7 )

```

## Exporting the Post-Processed Data Sets

Our last step of preprocessing is to export the data sets.  This need only but done once.

```{r eval=FALSE, echo = TRUE }

readr::write_csv(sdata_train_pp, "sdata_train_pp.csv", append = FALSE )

readr::write_csv(sdata_test_pp, "sdata_test_pp.csv", append = FALSE )

readr::write_csv(edata_test_pp, "edata_test_pp.csv", append = FALSE )

```

The above data files have the following properties and relationships to the original raw files:

```{r}

file_df = tibble( filename = c("sdata_train_pp.csv", "sdata_test_pp.csv", "edata_test_pp.csv"),
                  primary_key = c("id - consistent with sdata_test_pp", "id - consistent with sdata_train_pp", "id - standalone") ,
                  response = c("PH - unchanged", "PH - unchanged", "PH - unchanged" ) ,
                  
                  numeric_columns = c("BoxCox, center, scaled, imputed","BoxCox, center, scaled, imputed","BoxCox, center, scaled, imputed") ,
                  num_rows = c(2055, 512, 267 ) ,
                  file_source = c("StudentData.xlsx", "StudentData.xlsx", "StudentEvaluation.xlsx")
)

file_df %>% kable(caption = "Pre-Processed Data Files") %>% kable_styling(bootstrap_options = c("hover", "striped"
                                                                                            ), 
                                                                          position = "left")

```

An important note about the `id` column.   The `id` in the file `edata_test_pp.csv` is the row number of the same observation in `StudentEvaluation.xlsx`.   But the same is not true for `sdata_train_pp.csv` and `sdata_test_pp.csv` because they are sampled from the source file `StudentData.xlsx`.   The 10th row of `sdata_test_pp.csv` is not necessarily the 10th row of `StudentData.xlsx` rather one should use the `id` field as the corresponding row number of the original file.

## Importing the Pre-Processed Data

We load the pre-processed datasets for training and testing in this section.
We load the csv file for the training data set below and display the first few column characteristics from the file.

```{r data-load, echo = TRUE}

sdata_train_pp = read_csv("sdata_train_pp.csv", 
                          col_types = cols( .default = "?", id = "i" , BrandCode = "f")) %>% 
  as_tibble() %>% remove_rownames()

sdata_test_pp  = read_csv("sdata_test_pp.csv", col_types = cols( .default = "?", id = "i" , BrandCode = "f")) %>% 
  as_tibble() %>% remove_rownames()

sdata_trainX_pp  = sdata_train_pp %>% select( -PH, -id )
sdata_testX_pp   = sdata_test_pp %>% select(-PH , -id)
```

```{r echo = TRUE}
tuningFull = TRUE   # Set to TRUE if running the lengthy tuning process for all models
```

# Model Building

## Gradient Boosted Trees

We consider the same dataset and variable importance problem using gradient boosted trees.
The `gbm` library and variable importance measures are run within caret training procedure. The gradient boosting approach relies on a weak learner in an additive manner that minimizes the given loss function. 

```{r gbm-tuning, echo = TRUE , warning = FALSE}
set.seed(1027)

gbmControlFull <- trainControl(method = "repeatedcv", 
                           number = 10,  # for debug mode, set this to a low number (1)
                           repeats = 10 ,
                           selectionFunction = "best", 
                           verboseIter = FALSE)

gbmControlLight <- trainControl(method = "repeatedcv", 
                           number = 5,  # for debug mode, set this to a low number (1)
                           repeats = 1 ,
                           selectionFunction = "best", 
                           verboseIter = FALSE)

if(tuningFull == TRUE)
{
   gbmControl = gbmControlFull
   gbmTune = expand.grid( n.trees = seq(250, 1000, by = 250),
                                                  shrinkage = c( 0.02, 0.05,  0.1) ,
                                                  interaction.depth = c(  3, 7) ,
                                                  n.minobsinnode = 15
                                                  )
} else  {
   gbmControl = gbmControlLight
   gbmTune =  expand.grid( n.trees = c( 2000), 
                                                  shrinkage = c( 0.02, 0.05 , 0.1 ) ,
                                                  interaction.depth = c(  3, 7) ,
                                                  n.minobsinnode = 4
                                                  )
}

(gbmTune = caret::train( x = sdata_trainX_pp, 
                          y = sdata_train_pp$PH , 
                          method = "gbm",
                          tuneGrid =  gbmTune ,
                          verbose = FALSE,
                          metric = "RMSE" ,
                          trControl = gbmControl ) )
```

As the model output indicates the greater tree depth outperforms the lower counts and the shrinkage value of 0.05 produces the best RMSE value. The shrinkage, or learning rate, typically works better with smaller values, yet require longer processing time.

```{r}
gbm_plot <- ggplot(gbmTune) + labs(title = "Gradient Boosted Trees - Tuning")
gbm_plot
ggsave("GradientBoostedTreesTurning.jpg", gbm_plot)
```

The plot of the tuned model clearly shows the better performance with the increased max tree depth but also indicates the lower shrinkage value doesn't guarantee a lower RMSE. For the max tree depth of 3 and 7, the lowest shrinkage value does not produce the lowest RMSE for that tree depth.

```{r}
gbm_vi_plot <- ggplot(varImp(gbmTune, numTrees = gbmTune$finalModel$n.trees) ) + labs(title = "Gradient Boosted Trees - Variance Importance")
gbm_vi_plot
ggsave("GbmVarImp.jpg", gbm_vi_plot)
```

The variable importance plot shows the 100% importance of the `MnfFlow` followed by `BrandCode` as the only other variable with an importance above 50%. `Usagecont`, `OxygenFiller`, `AlchRel`, and `Temperature` round out the top 6 variables based on importance with scores greater than 25%.

Overall, the final Gradient Boosted model results in an RMSE of approximately 0.132 and an $R^2$ less than 0.5.

## Cubist

Now we train a Cubist tree using the `best` selectionFunction on RMSE. The `Cubist` library and variable importance measures are run within caret training procedure.\
The Cubist model is a rules-based approach in which the terminal leaves contains linear regression models. The models are based on predictions defined in the previous nodes of the tree.

```{r cubist-tuning, echo = TRUE, warning=FALSE, error = FALSE, message=FALSE}
set.seed(1027)

cubistControlFull <- trainControl(method = "cv" ,  selectionFunction = "best")
tuneGridFull  <- expand.grid( committees = c( 10, 50, 100 ) ,
                              neighbors = c( 0, 1, 5, 9 )
                                                  ) 

cubistControlLight <- trainControl(method = "cv" ,  selectionFunction = "best")
tuneGridLight <- expand.grid( committees = c( 10, 20 ) , 
                              neighbors = c( 0, 5 )  )

if(tuningFull == TRUE)
{
   cubistControl = cubistControlFull
   cubistGrid = tuneGridFull
} else  {
   cubistControl = cubistControlLight
   cubistGrid = tuneGridLight
}

(cubistTune = caret::train( x = sdata_trainX_pp, 
                          y = sdata_train_pp$PH , 
                          method = "cubist",
                          tuneGrid = cubistGrid ,
                          verbose = FALSE,
                          metric = "RMSE" ,
                          trControl = cubistControl ) )
```

The Cubist model results provide a strong RMSE value and $R^2$ value with generally a higher number of committees and neighbors.

The line plot confirms the better model per RMSE with neighbors at 5 and committees set to 50.

```{r}
cubist_plot <- ggplot(cubistTune) + labs(title="Cubist Model Tuning")
cubist_plot
ggsave("CubistTuning.jpg", cubist_plot)
```

The variable importance plot identifies `MnfFlow` as the most valuable variable followed by `Balling`, `BallingLvl`, `AlchRel`, and `PressureVacuum` to round out the top 5 variables. Overall, 7 variables resulted in over 50% importance indicating those variables are contained in over 50% of the rules defining the Cubist model.

```{r}
cubist_vi_plot <- ggplot(varImp(cubistTune), top = 20) + labs(title = "Cubist Model Variable Importance")
cubist_vi_plot
ggsave("CubistVarImp.jpg", cubist_vi_plot)
```

The final Cubist model confirms the high usage rate of the variable `MnfFlow`.

```{r}
cubistTune$finalModel$usage %>% arrange( desc(Model+ Conditions)) %>% 
  kable(caption = "Cubist Predictor Usage") %>% kable_styling(bootstrap_options = c("hover", "striped"), position = "left")
```

The `splits` plot indicates the usage of each variable by committee/rule. The values are normalized and highlight the high usage rate of `MnfFlow` along with the use of greater than or less than inequalities for `MnfFlow`.

```{r}
cubist_splitsplot <- dotplot( cubistTune$finalModel, what = "splits" )
cubist_splitsplot
```

```{r}
# Output to file
jpeg(file="CubistSplitsPlot.jpg")
cubist_splitsplot
dev.off()
```

The `dotplot` allows us to see the distribution of the coefficient parameters for each linear model associated with a committee/rule.\
When a predictor has more dots, it is used in more models which suggests the variable is influential. The color density is proportional to the variable importance.
The sign of the coefficient predicts the marginal effect of the predictor on the response `PH`. However, since Cubist uses many models, the concept of the `sign` of a predictor coefficient can be unclear.\
The x-axis value of the dot in the `dotplot` indicates the true coefficient in the original units unlike the above plot which normalizes the x-axis.

```{r}
cubist_dotplot <- dotplot( cubistTune$finalModel, 
         what = "coefs", 
         between = list(x = 0.2, y = 0.5) , 
         scales = list(x = list(relation = "free"),  
                       y = list(cex = 0.25)  ) )
cubist_dotplot
jpeg(file="CubistDotPlot.jpg")
cubist_splitsplot
dev.off()
```

The boxplot below which we devised constructs a distribution of coefficients for each predictor.
We interpret the sign of the predictor $X$ marginal effect to be the sign of the median of the distribution of coefficients pf $X$ over those models which include $X$.
The predictors have been sorted by their median.

The plot provides clarity regarding the impact of a given variable as the median is a good estimate of the sign of the variable coefficient. The `AlchRel` variable box indicates a positive relationship with the dependent variable `PH`. The most important variable `MnfFlow` box results in a negative coefficient, and thus an inverse effect on `PH`. For all the rules in the final Cubist model, the understanding of the coefficient values for each variable provides a clear relationship to the dependent variable despite the obtuse nature of the Cubist model construction.

```{r}
cubistTune$finalModel$coefficients %>% 
  rownames_to_column(var="id") %>% 
  select(-committee, -rule) %>% 
  pivot_longer(!id, names_to = "predictor", values_to = "coef" ) %>% 
  filter( !is.na(coef)) %>% 
  filter( predictor != '(Intercept)' )  %>%
  filter(abs(coef) < 20 ) -> coef_piv

cubist_boxplot <- coef_piv %>% 
  ggplot() + 
  geom_boxplot(
    aes(x=reorder(predictor, coef, FUN = median, na.rm = TRUE ),  # order the boxplots by median
        y = coef ), outlier.shape = NA ) +  # strip out the outliers
  coord_flip(ylim=c(-.5,.5)) +
  labs(title = "Distribution of Coefficients of Predictors", 
       subtitle = "from Cubist Committee/Rules",
       x = "Predictors" ,
       y = "Coefficient in Linear Model"
       )

cubist_boxplot
ggsave("CubistBoxPlot.jpg", cubist_boxplot)
```

Overall, the final Cubist model results in an RMSE under 0.1 and a $R^2$ just below of 0.7.

## CART

Using the `rpart` library and its training methods, we consider the best CART based on the `RMSE` metric. The CART approach follows a classification and regression tree methodology.

```{r cart-tuning, echo = TRUE, warning = FALSE}
set.seed(10393)

library(rpart)
cartGrid = expand.grid( maxdepth = seq( 1, 20, by = 1 )  )

cartControl <- trainControl(method = "boot", 
                            number = 30,  
                            selectionFunction = "best")

(rpartTune = train( x = sdata_trainX_pp, 
                    y = sdata_train_pp$PH ,
                   method = "rpart2" ,
                   metric = "RMSE" ,
                   tuneGrid = cartGrid ,
                   trControl = cartControl ) )
```

The model output shows increasing tree depth leads to improved RMSE and $R^2$ values.

The below plot displays the improving RMSE value with the increasing tree depth with an optimal tree depth of 19.

```{r}
cart_tuning_plot <- ggplot(rpartTune) + labs(title="CART Tree Tuning")
cart_tuning_plot
ggsave("CartTuningPlot.jpg", cart_tuning_plot)
```

Once again, the variable `MnfFlow` is the most important variable with an importance rating of 100%. Six variables achieve an importance score of greater than 50% with `BrandCode`, `Temperature`, and `CarbRel` each achieving greater than 75% importance.

```{r}
cart_vi_plot <- ggplot(varImp( rpartTune), top = 20 ) + labs(title = "CART Tree Variable Importance")
cart_vi_plot
ggsave("CartVarImp.jpg", cart_vi_plot)
```

The CART tree plot of the final model reaffirms the importance of the variable `MnfFlow` as the initial node splits on `MnfFlow`. One of the second level nodes is `BrandCode`, another highly important variable to the CART model. Eight ff the top 10 most important variables in the Cubist model are found in the top 15 variables of the CART model. This overlap of variable importance shows a consistency across the different model approaches.

```{r}
rpart.plot(rpartTune$finalModel, digits = 3)
```

Overall, the final CART model results in an RMSE of approximately 0.132 and an $R^2$ less than 0.5.

# MARS

Now we train a MARS model based on the implementation of earth from the `caret` library. The MARS approach is a non-linear regression model that does not rely on the original variables but instead on derived features. The tuned MARS model defines the derived features as linear combinations of the initial variables.

```{r  mars-tuning , message = FALSE, warning= FALSE, error= FALSE, class.source = 'code-bg'}

if( tuningFull == TRUE )
{
    marsGrid = expand.grid( .degree = 1:2, .nprune = seq(2,27, by=5) )
    marsControl = trainControl(method = "cv", 
                     number = 10, 
                
                     selectionFunction = "best", 
                     verboseIter = FALSE)
} else {
    marsGrid = expand.grid( .degree = 1:2, .nprune = seq(2,25, by = 10 ) )
    
    marsControl = trainControl(method = "cv", 
                     number = 10, 
                     
                     selectionFunction = "best", 
                     verboseIter = FALSE)
}
    

set.seed(1000)

marsTuned = caret::train(x = sdata_trainX_pp , 
                         y = sdata_train_pp$PH, 
                         method = "earth" ,
                         metric = "RMSE" , 
                         tuneGrid = marsGrid ,
                         trControl = marsControl )
```


```{r}
marsTuned$finalModel

summary(marsTuned)
```

The plot of the final MARS model indicates increasing the number of terms leads to a lower RMSE.

```{r}
mars_tuning_plot <- ggplot(marsTuned) + labs(title="MARS Model Tuning" )
mars_tuning_plot
ggsave("MarsTuningPlot.jpg", mars_tuning_plot)
```

Once again, the variable `MnfFlow` achieves an importance score of 100%. Only 3 variables reach the score of 50%, the aforementioned `MnfFlow`, `BrandCodeC`, and `AlchRel`.

The variable `MnfFlow` is influential because the variable effects many other variables in the final model. Due to the numerous linear combinations including `MnfFlow`, the relationship to `PH` is difficult to ascertain. The `MnfFlow` variable requires more investigation into the variable interactions to determine the impact to `PH` for the MARS model.

```{r}
mars_vi_plot <- ggplot( varImp(marsTuned), 20 ) + labs(title = "MARS Model Variable Importance")
mars_vi_plot
ggsave("MarsVarImp.jpg", mars_vi_plot)
```

Overall, the MARS model reaffirms the importance of the variable `MnfFlow` and also results in an RMSE and $R^2$ in line with the previous models for Gradient Boosted Trees and CART.

# Linear Regression

We also run a simple OLS regression on PH in terms of the scaled and centered variables.
While its predictive performance is weaker than the other models on the training set, the coefficients are much easier to interpret.

```{r}
set.seed(123)

train.control <- trainControl( method = "cv", number = 5)

linearTune = train( PH ~ . -id, 
                    data = sdata_train_pp, 
                    method = "lm", 
                    tuneGrid = data.frame(intercept = TRUE),
                    trControl = train.control)

summary(linearTune$finalModel)
```

The most significant variables are `MnfFlow`, `CarbPressure`, `HydPressure3`, `Temperature`, `Usagecont`, `Balling`, `PressureVacuum`, `OxygenFiller`, `BowlSetpoint`, `BallingLvl`, and `BrandCode`. Seven of these 11 variables are found in the top 10 most important variables of the Cubist model. Upon closer evaluation, the median value of the variable coefficients from the top 10 of the Cubist model match the sign of the coefficient value in the linear regression model. This finding further supports the assessment of the Cubist model variable impacts on the dependent variable `PH`.

We summarize the plot of coefficients below.

```{r}
par(mfrow=c(2,2))

lm_final_model_plot <- plot(linearTune$finalModel)
lm_final_model_plot
#ggsave("LinearModelFinalPlot.jpg", lm_final_model_plot)
```

```{r}
hist(linearTune$finalModel$residuals)
```

The diagnostic plots of the OLS model suggest that the histogram of residuals is relatively symmetric and looks normal.\
The QQ plot suggests the model fit does not fully capture the fat tails possibly due to a small number of outliers.

Overall, the linear regression model does not perform as well as the Cubist model but does provide a valuable sanity check and baseline to the results from the more advanced models.

# Model Selection

Based on the above results, we summarize their training and test RMSE and $R^2$ below.

The joint results are tabulated below.

```{r compare-model-results , echo = TRUE }

# Make a list of model results collect them from caret for both training and test data and compare them jointly in a kable()

model_list = list( rpartTune , marsTuned , gbmTune, cubistTune, linearTune)

model_stats = data.frame()

for( modelObj in model_list )
{
    if( modelObj$method != 'lm' ){
        pred_data <- as.numeric( predict( modelObj, newdata=sdata_testX_pp ))[]
    }
    else
    {
        pred_data <- as.numeric( predict( modelObj, newdata=sdata_test_pp ))
    }
    output <- data.frame( modelName = modelObj$method ,
                     trainRMSE = getTrainPerf(modelObj)[1,1] ,
                     trainR2   = getTrainPerf(modelObj)[1,2] ,
                     testRMSE  = caret::RMSE( pred_data,  sdata_test_pp$PH) ,
                     testR2    = caret::R2(   pred_data,  sdata_test_pp$PH) 
                     )

    model_stats <- rbind(model_stats, output)
}

```

```{r}
results_table <- model_stats %>% as_tibble() %>% 
  arrange( testRMSE) %>%
  kable( digits = 3, caption = "Model Results Comparison") %>%
  kable_styling(bootstrap_options = c("hover", "striped"), position = "left")

results_table

save_kable(results_table, "ModelResultsTable.jpg")
```

We also inspect the plot of the predicted versus the observed data for the 5 models.
The scatterplots below confirm the Cubist model outperforms the others on both the training set in the upper row and also the test data on the lower rows. The distribution of the Cubist plot mostly closely aligns with the 45-degree line which corresponds to an accurate prediction.

```{r}
predVals = extractPrediction(list(marsTuned, rpartTune, cubistTune, gbmTune), testX = sdata_testX_pp , testY = sdata_test_pp$PH )

# Attempting to hack into the extract prediction object with the LM data
# Cols: obs pred model dataType object
pred_lm =  predict(linearTune, newdata = sdata_test_pp)
pred_lm_train <- linearTune$finalModel$fitted.values

# Create placeholder data for the training values
model_l <- rep("LM", length = 2055)
dt_l <- rep("Training", length = 2055)
obj_l <- rep("Object9", length = 2055)

# Create dataframe of the training data of LM
lm_train_preds <- as.data.frame(cbind(obs=sdata_train_pp$PH, pred=pred_lm_train, model=model_l, dataType=dt_l, object=obj_l), row.names = NULL)

# Create placeholder data for the test values
model_l <- rep("LM", length = 512)
dt_l <- rep("Test", length = 512)
obj_l <- rep("Object10", length = 512)

# Create dataframe of the test data of LM
lm_test_preds <- as.data.frame(cbind(obs=sdata_test_pp$PH, pred=pred_lm, model=model_l, dataType=dt_l, object=obj_l), row.names = NULL)

# Combine all data for plotting
all_preds <- rbind(predVals, lm_train_preds, lm_test_preds)

# Ensure obs and preds are numerics
all_preds$obs <- as.numeric(all_preds$obs)
all_preds$pred <- as.numeric(all_preds$pred)

# Plot using Caret built-in reporting.
# --------------------------------------
obsVsPredsPlot <- plotObsVsPred(all_preds)
obsVsPredsPlot
#ggsave("ObsVsPredsPlot.jpg", obsVsPredsPlot)
```

# Discussion

We conclude that the best model is Cubist but the multilinear regression model, MARS and CART models provide useful insight on the main predictors.

-   We would recommend the use of the Cubist model for prediction
-   However, the OLS (ordinary least squares) linear regression help us to understand the sign and magnitude of the most important variables.
-   The MARS model helps to detect non-linearity and predictor interaction in prediction.

The top 5 variables that impact PH are:

-   `MnfFlow` - this appears negatively related to `PH` level based on OLS, MARS and Cubist median plot.

-   `BallingLvl` is positively related to `PH` level.

-   `PreserveVacuum` is negatively related to `PH.`

-   `AlchRel` is positively related to `PH`.

-   `Balling` is negatively related to `PH`.

Lastly, we observe that Brand is probably not a manufacturing predictor that can be controlled.
Mostly likely Brand refers to a recipe for the final product.
However, knowing the desired optimal `PH` for each Brand may help us control the most influential variables that control `PH`, thereby providing better quality control.
While there are over 30 predictors in the dataset, we recommend looking at the top 10 most influential predictors.
Most of the models agree substantially on which predictors to include in the top 10.

For example, the linear regression model coefficients agree with the sign and variable importance of the top 10 predictors of the Cubist model.
Importance predictors of the OLS model have the highest statistical significance - consistent with variable importance measure of `caret`.

# Final Predictions

```{r warning=F, error=F}
# Combine the initial training and test datasets into 1
sdata_trainfull_pp <- rbind(sdata_train_pp, sdata_test_pp)
sdata_trainfullX_pp <- sdata_trainfull_pp %>% select(-PH , -id)

edata_test_pp = read_csv("edata_test_pp.csv", 
                          col_types = cols( .default = "?", id = "i" , BrandCode = "f")) %>% 
  as_tibble() %>% remove_rownames()

# Train the Cubist model
set.seed(1027)

if(tuningFull == TRUE)
{
   cubistControl = cubistControlFull
   cubistGrid = tuneGridFull
} else  {
   cubistControl = cubistControlLight
   cubistGrid = tuneGridLight
}

(cubistTune = caret::train( x = sdata_trainfullX_pp, 
                          y = sdata_trainfull_pp$PH , 
                          method = "cubist",
                          tuneGrid = cubistGrid ,
                          verbose = FALSE,
                          metric = "RMSE" ,
                          trControl = cubistControl ) )

# Make predictions on the provided dataset
final_pred_data <- as.numeric( predict( cubistTune, newdata=edata_test_pp ))

# Output prediction performance
full_cubist_train_rmse <- getTrainPerf(cubistTune)[1,1]
full_cubist_train_r2   <- getTrainPerf(cubistTune)[1,2]
```

RMSE of the full StudentData dataset: `r full_cubist_train_rmse`.

$R^2$ of the full StudentData dataset: `r full_cubist_train_r2`.

```{r}
# Output predictions to Excel file
raw_StudentEvaluation <- read_excel("StudentEvaluation.xlsx")
raw_StudentEvaluation$PH <- final_pred_data
write_xlsx(raw_StudentEvaluation, "ANg_PTanofsky_Ph_Predictions.xlsx")
```

# Code

We summarize all the R code used in this project in this appendix for ease of reading.

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}

```
